## 목차
~~~
1. 유니언 타입과 교차 타입의 사용 사례
2. 유니언 타입에서의 타입 가드
3. 교차 타입의 장점과 사용법
~~~

## Union
~~~typescript
// uniton
const union = 'a' | 'b' | 'c';

// discriminate type
type discrimitae =
  | {
  type: 'a';
  a: string;
} } {
  type: 'b';
  b: string;
} | {
  type: 'c';
  c: string;
  d: string; // 다른 타입이 있어도 상관없어요
}

// enum으로도 표현 가능
enum enumType {
  a,
  b,
  c
}
~~~
<img width="300" alt="image" src="https://github.com/KoGaYoung/TS-study/assets/36693355/a3095454-ec39-4c34-be69-e1f76d866370">

## 1. 유니언 타입과 교차 타입의 사용 사례
~~~typescript
// 유니언('|')은 "또는" 이라는 뜻으로 합집합(두개 중 어디든 속하면 ok)입니다.

// 파라미터가 string나 number로 들어오면 ok
const func(message: string | number) => {
  console.log(message);
}
~~~
<img width="300" alt="image" src="https://github.com/KoGaYoung/TS-study/assets/36693355/143e0502-1e02-4189-a28a-7bff8c74a099">

## 2. 유니언 타입에서의 타입 가드
~~~typescript
// 타입가드 : 유니언을 사용할 때 특정 타입에만 있는 속성, 메소드를 사용하기 위한 방어로직

// 여기서는 isNumber가 타입가드
const func(message: string | number): string => {
  return isNumber(message) ? 
    message.toString()
    :
    message
}
~~~

## 3. 교차 타입(Intersection Type)의 장점과 사용법
~~~typescript
// 교차타입('&')은 교집 합개념으로 A와 B를 둘다 만족해야한다.
// & 연산자는 정확히 말하면 A와 B를 둘 다 만족하는 새로운 타입을 생성해낸다.

interface IHome {
  address: string;
  location: string;
}

interface IOwner {
  name: string;
}

type homeInfo = IHome & IOwner; // { address: string; location: string; name: string }


const a : homeInfo = {
    address: '서울특별시 구로구',
    location: '구로구',
    name: '가영'
}
~~~
<img width="300" alt="image" src="https://github.com/KoGaYoung/TS-study/assets/36693355/7623b4cd-3415-4572-a30b-e5646ccf9fde">
