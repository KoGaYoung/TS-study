## 목차
~~~
1. 제너릭을 사용하는 이유(any와 비교)
2. 기본 제너릭 타입 정의(function, interface, type, class)
3. 제너릭 제약조건, 타입매개변수 사용
4. 제너릭 유틸리티 타입
  4-1.	Partial<T>
  4-2.	Readonly<T>
  4-3.	Record<K,T>
  4-4.	Pick<T,K>
  4-5.	Omit<T,K>
  4-6.	Exclude<T,U>
  4-7.	Extract<T,U>
  4-8.	NonNullable<T>
  4-9.	Parameters<T>
  4-10.	ConstructorParameters<T>
  4-11.	ReturnType<T>
  4-12.	InstanceType<T>
  4-13.	Required<T>
  4-14.	ThisParameterType
  4-15.	OmitThisParameter
  4-16.	ThisType<T>
~~~

## 1. 제너릭을 사용하는 이유(any와 비교)
~~~
타입스크립트로 한가지 타입이 아니라 여러가지 타입을 받아야할 때 any를 사용할 경우 타입을 잃어버려요
~~~
~~~typescript
// 원래 소스
const func = (message: string): string => {
    return message
}

console.log(func('1'));
~~~
~~~typescript
// 여러가지 타입을 받아야 할 경우 -> any -> 타입 잃어버림
const funcAny = (message: any): any => {
    return(message);
}

// 뭘 넣든 호출시그니처 확인 시 any타입
console.log(funcAny(1)); // const funcAny: (message: any) => any
~~~
~~~typescript
// T(타입변수) 사용해서 제네릭 타입 표현
const funcType = <T>(message: T):T => {
    return message;
};


console.log(funcType(1)); // const funcType: <1>(message: 1) => 1  (타입 매개변수를 생략: T는 1타입이 됨)

// 복잡한 타입유추 시에는 아래처럼 타입 명시 필요  (타입 매개변수를 명시적으로 지정)
console.log(funcType<number>(1)); // const funcType: <number>(message: number) => number
~~~

## 2. 기본 제너릭 타입 정의(function, interface, type, class)
~~~typescript
// 일반 함수
function funcType<T>(message:T) : T{
    return message;
}

// 익명함수
const funcType = function<T>(message: T):T {
    return message;
};

// 화살표함수
const funcType = <T>(message: T):T => {
    return message;
};
~~~
~~~typescript
// interface

interface IResponse<T> {
    status: number;
    code: string;
    message: string;
    data: T;
}

// 타입매개변수 { flag : boolean } 으로 지정
const response: IResponse<{ flag: boolean }> = {
    status: 200,
    code: 'error.code.00000',
    message: '',
    data: { flag: true }
}
~~~
~~~typescript
// type
type TResponse<T> = {
    status: number;
    code: string;
    message: string;
    data: T;
}

// 타입매개변수 { flag : boolean } 으로 지정
const tResponse: TResponse<{ flag: boolean }> = {
    status: 200,
    code: 'error.code.00000',
    message: '',
    data: { flag: true }
}
~~~

~~~typescript
// class
class getnericClass<T> {
    type: T;
    add: (x: T, y: T) => T;

    constructor(type: T) {
        this.type = type;
        this.add = (x: T, y: T) => {
            if (typeof x === 'number') {
                return x
            }
            else {
                return y;
            }
        }
    }
}

const myGenericClass = new getnericClass<number>(10);
const myGenericStringClass = new getnericClass<string>('');
~~~

## 3.	제너릭 제약조건
~~~
제너릭 제약조건을 사용아면 특정 타입만 요구할 수 있어서 안정성 올라감
~~~
~~~typescript
interface IData{
    array : number[];
    length: number;
}

const returnLnegth = <T extends IData>(param: T): number =>{
    return param.length;
}

// array와 length는 반드시 만족하기만 하면 ok
console.log(returnLnegth({array: [1,2,3], length: 3, optionData: '1'}));
~~~

## 4.	제너릭 유틸리티 타입
~~~typescript
// 4-1. Partial<T>

// Partial
type TPartial<T> = {
    // [P in T]는 mapped 타입, P는 속성이름(키) T는 가능한 유니언
    // 키밸류가 여러개 들어올꺼니까!
    [P in keyof T]? : T[P] 
}

type MyType = { a: string, b: number };

// 구현한거 사용
const func = (param : TPartial<MyType>) => {
    console.log(param.a, param.b);
}

// 유틸리티 함수 사용
const func2 = (param : Partial<MyType>) => {
    console.log(param.a, param.b);
}
~~~
~~~typescript
// 4-2.	Readonly<T>

// 모든 속성을 읽기 전용으로 만들어요

// ReadOnly
type TReadOnly<T> = {
    readonly [P in keyof T] : T[P]
}

type MyType = { a: string, b: number };

// 구현한거 사용
let param: TReadOnly<MyType> = { a: 'string', b: 0};
param.a = 'string2';

// 유틸리티 함수 사용
let para2: Readonly<MyType> = { a: 'string', b: 0};
param.a = 'string2';
~~~
~~~typescript
// 4-3.	Record<T,K>

// T를 속성의 키로, K를 벨류로 사용
// 키인 T에 매칭하는 K가 구체적일 때 사용
type TRecord<T extends keyof any, K> = {
    // 반복되니까 [P in T] mapped 타입으로 표현
    [P in T]: K
}

type User = {
    id: number;
    name: string;
}

// 구현한거 사용
const userArray: TRecord<number, User> = {
    0: {id: 0, name: 'gayoung'},
    1: {id: 1, name: 'kong'}
}


// 유틸리티 함수 사용
const userArray2: Record<number, User> = {
    0: {id: 0, name: 'gayoung'},
    1: {id: 1, name: 'kong'}
}

// 인덱스 시그니처 사용 
type TUser = {
    [id: number]: User;
}

const userArray3: TUser = {
     0: {id: 0, name: 'gayoung'},
    1: {id: 1, name: 'kong'}
}

// 인덱스 시그니처 객체의 이름과 속성을 미리 알 필요 없고 추가도 가능해서 훨신 유연함
type TPerson = {
    [key in string] : string | number;
}

const person1: TPerson = {
    name: 'gayoung',
    id: 27
}

person1.email = 'kogayoung@naver.com';
~~~
~~~typescript
// 4-4.	Pick<T,K>

// T에서 K속성만 가지는 타입 생성
// K를 T의 keyof으로 만들어서 반복문으로 mapped하게 만들기
type TPick<T, K extends keyof T> = {
    [P in K]: T[K]
}


interface IResponse<T>{
    code: number;
    message: string;
    data: T
}

type c = TPick<IResponse<{flag: boolean}>, 'data'>;
type b = Pick<IResponse<{flag: boolean}>, 'data'>; // { data: {flag: boolean } }

~~~

~~~typescript
// 4-5. Exclude<T,U>

// T에서 유니언 타입 U에 해당하는 속성 제외

type TExclude<T, U> = T extends U ? never : T; 

interface IResponse<T>{
    code: number;
    message: string;
    data: T
}

type c = TExclude<IResponse<{flag: boolean}>, {code: number} | {message: string}>; // never
type b = Exclude<IResponse<{flag: boolean}>, {code: number} | {message: string}>; // never

// type Exclude<T, U> = T extends U ? never : T U가 T에 확장형이면 없애고, 아닌것만 리턴
type T0 = Exclude<"a" | "b" | "c", "a">;  // "b" | "c"
type T1 = Exclude<"a" | "b" | "c", "a" | "b">; // "c"
~~~
~~~typescript
// 4-6. Omit<T,K>

// T에서 K 제외한 타입 생성
type TOmit<T, K> = Pick<T, Exclude<keyof T, K>>;

interface IResponse<T>{
    code: number;
    message: string;
    data: T
}

type c = TOmit<IResponse<{flag: boolean}>, 'data'>;
type b = Omit<IResponse<{flag: boolean}>, 'data'>; // {code: number; message: string;}
~~~
~~~typescript
// 4-7.	Extract<T,U>

// T에서 U에 해당하는 속성들만 추출
type Extract<T, U> = T extends U ? T : never;

type T0 = Extract<"a" | "b" | "c", "a">;  // "a"
type T1 = Extract<"a" | "b" | "c", "a" | "b" | "F">; // "a" | "b"
~~~
~~~typescript
// 4-8.	NonNullable<T>

// null과 undefined 제외타입 생성 ({}와 같은의미)

type TNonNullable<T> = T extends {} ? T : never; // type NonNullable<T> = T & {} 이렇게 쓴다 

type b = TNonNullable<string | number | undefined>; // string | number
type a = NonNullable<string | number | undefined>;  // string | number
~~~
~~~typescript
// 4-9.	Parameters<T>

// 함수타입 T 매개변수와 타입을 튜플로 추출

~~~
~~~typescript
// 4-10. ConstructorParameters<T>

// 클래스타입 생성자 T의 매개변수들을 튜플로 추출 
~~~
~~~typescript
// 4-11. ReturnType<T>

// 함수타입 T의 리턴 추출
~~~
~~~typescript
// 4-12. InstanceType<T>

// 생성자 함수타입 T의 인스턴스 타입 추출 
~~~
~~~typescript
// 4-13. Required<T>

// T의 모든속성 필수로 만듬
~~~
~~~typescript
// 4-14. ThisParameterType
~~~
~~~typescript
// 4-15. OmitThisParameter
~~~
~~~typescript
// 4-16. ThisType<T>
~~~
