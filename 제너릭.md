## 목차
~~~
1. 제너릭을 사용하는 이유(any와 비교)
2. 기본 제너릭 타입 정의(function, interface, type, class)
3.	제너릭 제약조건, 타입매개변수 사용
4.	제너릭 유틸리티 타입
  4-1.	[Partial<T>
  4-2.	Readonly<T>
  4-3.	Record<K,T>
  4-4.	Pick<T,K>
  4-5.	Omit<T,K>
  4-6.	Exclude<T,U>
  4-7.	Extract<T,U>
  4-8.	NonNullable<T>
  4-9.	Parameters<T>
  4-10.	ConstructorParameters<T>
  4-11.	ReturnType<T>
  4-12.	InstanceType<T>
  4-13.	Required<T>
  4-14.	ThisParameterType
  4-15.	OmitThisParameter
  4-16.	ThisType<T>
~~~

## 1. 제너릭을 사용하는 이유(any와 비교)
~~~
타입스크립트로 한가지 타입이 아니라 여러가지 타입을 받아야할 때 any를 사용할 경우 타입을 잃어버려요
~~~
~~~typescript
// 원래 소스
const func = (message: string): string => {
    return message
}

console.log(func('1'));
~~~
~~~typescript
// 여러가지 타입을 받아야 할 경우 -> any -> 타입 잃어버림
const funcAny = (message: any): any => {
    return(message);
}

// 뭘 넣든 호출시그니처 확인 시 any타입
console.log(funcAny(1)); // const funcAny: (message: any) => any
~~~
~~~typescript
// T(타입변수) 사용해서 제네릭 타입 표현
const funcType = <T>(message: T):T => {
    return message;
};


console.log(funcType(1)); // const funcType: <1>(message: 1) => 1  (타입 매개변수를 생략: T는 1타입이 됨)

// 복잡한 타입유추 시에는 아래처럼 타입 명시 필요  (타입 매개변수를 명시적으로 지정)
console.log(funcType<number>(1)); // const funcType: <number>(message: number) => number
~~~

## 2. 기본 제너릭 타입 정의(function, interface, type, class)
~~~typescript
// 일반 함수
function funcType<T>(message:T) : T{
    return message;
}

// 익명함수
const funcType = function<T>(message: T):T {
    return message;
};

// 화살표함수
const funcType = <T>(message: T):T => {
    return message;
};
~~~
~~~typescript
// interface

interface IResponse<T> {
    status: number;
    code: string;
    message: string;
    data: T;
}

// 타입매개변수 { flag : boolean } 으로 지정
const response: IResponse<{ flag: boolean }> = {
    status: 200,
    code: 'error.code.00000',
    message: '',
    data: { flag: true }
}
~~~
~~~typescript
// type
type TResponse<T> = {
    status: number;
    code: string;
    message: string;
    data: T;
}

// 타입매개변수 { flag : boolean } 으로 지정
const tResponse: TResponse<{ flag: boolean }> = {
    status: 200,
    code: 'error.code.00000',
    message: '',
    data: { flag: true }
}
~~~

~~~typescript
// class
class getnericClass<T> {
    type: T;
    add: (x: T, y: T) => T;

    constructor(type: T) {
        this.type = type;
        this.add = (x: T, y: T) => {
            if (typeof x === 'number') {
                return x
            }
            else {
                return y;
            }
        }
    }
}

const myGenericClass = new getnericClass<number>(10);
const myGenericStringClass = new getnericClass<string>('');
~~~

## 3.	제너릭 제약조건
~~~
제너릭 제약조건을 사용아면 특정 타입만 요구할 수 있어서 안정성 올라감
~~~
~~~typescript
interface IData{
    array : number[];
    length: number;
}

const returnLnegth = <T extends IData>(param: T): number =>{
    return param.length;
}

// array와 length는 반드시 만족하기만 하면 ok
console.log(returnLnegth({array: [1,2,3], length: 3, optionData: '1'}));
~~~

## 4.	제너릭 유틸리티 타입
~~~typescript
// 4-1.	Partial<T>
~~~
~~~typescript
// 4-2.	Readonly<T>
~~~
~~~typescript
// 4-3.	Record<K,T>
~~~
~~~typescript
// 4-4.	Pick<T,K>
~~~
~~~typescript
//  4-5. Omit<T,K>
~~~
~~~typescript
//  4-6.	Exclude<T,U>
~~~
~~~typescript
//  4-7.	Extract<T,U>
~~~
~~~typescript
// 4-8.	NonNullable<T>
~~~
~~~typescript
// 4-9.	Parameters<T>
~~~
~~~typescript
// 4-10.	ConstructorParameters<T>
~~~
~~~typescript
// 4-11.	ReturnType<T>
~~~
~~~typescript
// 4-12.	InstanceType<T>
~~~
~~~typescript
// 4-13.	Required<T>
~~~
~~~typescript
// 4-14.	ThisParameterType
~~~
~~~typescript
// 4-15.	OmitThisParameter
~~~
~~~typescript
// 4-16.	ThisType<T>
~~~
