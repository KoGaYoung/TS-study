## 목차
~~~
1. keyof, typeof 연산자
2. indexd type(인덱스 접근 유형)
3. 조건부 타입
4. mapped 타입 ( + 맵드 타입(Mapped Types)에서 속성을 제거하는 데 사용 하는 (-) 연산자 )
5. 템플릿 리터럴
6. 선택적 속성(?), readonly 연산자 - 1에서 함 (생략)
7. Non-null 단언 연산자(!)
~~~

## 1. typeof, keyof 연산자
~~~
typeof 는 주어진 식의 값이 null인지, undefined인지, number인지 나타내는 역할을 하는 연산자입니다.
뎁스가 깊어도 동작합니다.
~~~
~~~typescript
const a = {
  "name": "John",
  "age": 30,
  "address": {
    "street": "Main Street",
    "city": "New York",
    "state": "NY"
  }
}
~~~
~~~typescript
type checkAType = typeof a; // 생략(a의 타입이 그대로 추론됩니다)

// address의 주소도 잘 표시해요
type aAddress = typeof a.address;
~~~

~~~
keyof 연산자는 객체의 타입을 받아 key로 구성된 문자열 또는 숫자 유니온 타입을 생성합니다.
~~~

~~~typescript
const a = {
  "name": "John",
  "age": 30,
}; // } as const; 

// keyof은 타입에서만 동작해서 typeof 가 필요해요 (key를 상수타입처럼 써서 enum 대체가능)
type aKey = keyof typeof a; // type attr = "name" | "age";

// enum 처럼 사용하는 방법 (as const를 사용하여 stirng|number 에서 "Jhon" | 30으로 추출할 수 있어요.)
type aValue = typeof a[aKey]; // stirng|number
~~~

## 2. indexd type(인덱스 접근 유형)

~~~
객체나 배열의 특정 속성이나 요소에 접근할 때 사용하는 타입
~~~

~~~typescript
type Person = { age: number; name: string; alive: boolean };

// 인덱스 접근 유형을 통해 특정 속성의 타입을 가져와요
type TAgeValue = Person["age"]; // number

// keyof 명령어로 value의 타입을 뽑을 수 있어요
type TPersonValue = Person[keyof Person]; // string | number | boolean
~~~

~~~
consg 객체 타입을 value를 뽑아올 때는 typeof a[keyof typeof a]
타입 객체의 value를 뽑아올 때는 Person[keyof Person]

존재하지 않는 속성은 오류가 표시되어요
~~~

~~~typescript
const MyArray = [
  { name: "Alice", age: 15 },
  { name: "Bob", age: 23 },
  { name: "Eve", age: 38 },
];

// 배열안에 들어있는 객체도 예쁘게 표기 가능
// 인덱스 접근 유형이 없었더라면 Array<{ name: string; age: number; }> 이렇게 선언해줘야함.
type TPerson = typeof MyArray[number]; // type TPerson = { name: string; age: number; }
~~~

~~~typescript
type key = "age"; // 됨
// const key = "age"; // 안됨
type Age = TPerson[key];

// -> 인덱스드 접근 유형은 타입스페이스 값으로만 접근 가능, 벨류스페이스 값은 접근이 안됨
~~~

## 3. 조건부 타입 ( + infer )
~~~typescript
SomeType extends OtherType ? TrueType : FalseType;
// 이런 형태로 작성된 것으로, 입력 유형과 출력 유형 간의 관계를 설명함
// 입력유형은 조건인 SomeType extends OtherType
// 출력유형은 결과인 TrueType : FalseType
~~~
~~~typescript
interface Animal {
  live(): void;
}
interface Dog extends Animal {
  woof(): void;
}
 
type Example1 = Dog extends Animal ? number : string; // Number
 
type Example2 = RegExp extends Animal ? number : string; // string
~~~

~~~typescript
interface IdLabel {
  id: number /* some fields */;
}
interface NameLabel {
  name: string /* other fields */;
}
 
function createLabel(id: number): IdLabel;
function createLabel(name: string): NameLabel;
function createLabel(nameOrId: string | number): IdLabel | NameLabel;
function createLabel(nameOrId: string | number): IdLabel | NameLabel {
  throw "unimplemented"; // 구현되지 않았음을 알려주는 임시코드
}
~~~
~~~
ID -> IdLabel, name -> NameLabel리턴하는 오버로드,
여기서 만약 boolLabel 같은 인터페이스가 추가되면.. 함수 오버로딩은 2개 추가되고, 지속적으로 늘어난다.
interface boolLabel {
  flag: boolean;
}
~~~
~~~
// 이렇게 조건부 유형으로 인코딩해서 한번에 표현 가능
type NameOrId<T extends number | string> = T extends number
  ? IdLabel
  : NameLabel;
  
function createLabel<T extends number | string>(idOrName: T): NameOrId<T> {
  throw "unimplemented";
}

let a = createLabel("typescript"); // NameLabel
let b = createLabel(2.8); // IdLabel
~~~

4. mapped 타입 ( + 맵드 타입(Mapped Types)에서 속성을 제거하는 데 사용 하는 (-) 연산자 )


5. 템플릿 리터럴 

## 6. 선택적 속성(?), readonly 연산자 - 1에서 함 (생략)
~~~
~~~

## 7. Non-null 단언 연산자(!)
~~~
Non-null 단언 연산자(!)는 변수 뒤에 위치하여 해당 변수의 값이 null이나 undefined가 아님을 단언하는데 사용
타입어설션(as)와 같은 맥락으로 개발자가 타입을 단언할 수 있을때 사용해요. 컴파일러에게 알려주기 위함
~~~
~~~typescript
let someValue: string | null = "This is a string";

//!를 통해 someValue는 null과 undefined가 아니라고 단언함.
console.log(someValue!.length); // 16
~~~
~~~
보자마자 옵셔널 체이닝 연산자 (?)랑 헷갈릴 수 있다
console.log(someValue?.length); // null이나 undefined면 undefined를 반환, 아니면 16반환
~~~
