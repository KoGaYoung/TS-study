## 목차
~~~
1. keyof, typeof 연산자
2. indexd type(인덱스 접근 유형)
3. 조건부 타입
4. mapped 타입 ( + 맵드 타입(Mapped Types)에서 속성을 제거하는 데 사용 하는 (-) 연산자 )
5. 템플릿 리터럴
7. 선택적 속성(?), readonly 연산자 - 1에서 함 (생략)
8. Non-null 단언 연산자(!)
~~~

## 1. typeof, keyof 연산자
~~~
typeof 는 주어진 식의 값이 null인지, undefined인지, number인지 나타내는 역할을 하는 연산자입니다.
뎁스가 깊어도 동작합니다.
~~~
~~~typescript
const a = {
  "name": "John",
  "age": 30,
  "address": {
    "street": "Main Street",
    "city": "New York",
    "state": "NY"
  }
}
~~~
~~~typescript
type checkAType = typeof a; // 생략(a의 타입이 그대로 추론됩니다)

// address의 주소도 잘 표시해요
type aAddress = typeof a.address;
~~~

~~~
keyof 연산자는 객체의 타입을 받아 key로 구성된 문자열 또는 숫자 유니온 타입을 생성합니다.
~~~

~~~typescript
const a = {
  "name": "John",
  "age": 30,
}; // } as const; 

// keyof은 타입에서만 동작해서 typeof 가 필요해요 (key를 상수타입처럼 써서 enum 대체가능)
type aKey = keyof typeof a; // type attr = "name" | "age";

// enum 처럼 사용하는 방법 (as const를 사용하여 stirng|number 에서 "Jhon" | 30으로 추출할 수 있어요.)
type aValue = typeof a[aKey]; // stirng|number
~~~

## 2. indexd type(인덱스 접근 유형)

~~~
객체나 배열의 특정 속성이나 요소에 접근할 때 사용하는 타입
~~~

~~~typescript
type Person = { age: number; name: string; alive: boolean };

// 인덱스 접근 유형을 통해 특정 속성의 타입을 가져와요
type TAgeValue = Person["age"]; // number

// keyof 명령어로 value의 타입을 뽑을 수 있어요
type TPersonValue = Person[keyof Person]; // string | number | boolean
~~~

~~~
consg 객체 타입을 value를 뽑아올 때는 typeof a[keyof typeof a]
타입 객체의 value를 뽑아올 때는 Person[keyof Person]

존재하지 않는 속성은 오류가 표시되어요
~~~

~~~typescript
const MyArray = [
  { name: "Alice", age: 15 },
  { name: "Bob", age: 23 },
  { name: "Eve", age: 38 },
];

// 배열안에 들어있는 객체도 예쁘게 표기 가능
// 인덱스 접근 유형이 없었더라면 Array<{ name: string; age: number; }> 이렇게 선언해줘야함.
type TPerson = typeof MyArray[number]; // type TPerson = { name: string; age: number; }
~~~

~~~typescript
type key = "age"; // 됨
// const key = "age"; // 안됨
type Age = TPerson[key];

// -> 인덱스드 접근 유형은 타입스페이스 값으로만 접근 가능, 벨류스페이스 값은 접근이 안됨
~~~

